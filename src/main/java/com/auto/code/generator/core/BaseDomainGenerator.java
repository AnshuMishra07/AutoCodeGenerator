package com.auto.code.generator.core;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.auto.code.generator.specification.ApiSpecification;
import com.auto.code.generator.specification.JavaType;
import com.auto.code.generator.specification.Utility;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JFieldVar;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JPackage;

/**
 * @author Anshu Mishra
 *
 */
public class BaseDomainGenerator {
	private static final String PACKAGE_NAME = ".domain";

	protected void generateCore(JCodeModel codeModel, String className, HashMap<String, Object> feilds,
			String basePackage, ApiSpecification specification, String autoGeneRatedFilePath) throws Exception {
		JPackage jp = codeModel._package(basePackage + PACKAGE_NAME);
		JDefinedClass jc = null;
		if (jp._getClass(className) != null) {
			jc = jp._getClass(className);
		} else {
			jc = jp._class(className);
			jc._implements(Serializable.class);
			jc.javadoc().add("Auto generated " + jc.name() + " class");
			jc.constructor(JMod.PUBLIC).javadoc().add("Creates a new " + jc.name() + Constant.CURRENT_DIR);
			jc.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, Long.class, "serialVersionUID", JExpr.lit(1L));
		}
		JsonNode jsonNode = new ObjectMapper().convertValue(feilds, JsonNode.class);
		Iterator<Map.Entry<String, JsonNode>> fields = jsonNode.fields();
		while (fields.hasNext()) {
			Map.Entry<String, JsonNode> entry = fields.next();
			if (entry.getValue().isObject() && entry.getValue().asToken().START_OBJECT.name().equals("START_OBJECT")) {
				generateObjectClass(codeModel, Utility.constructCamelCase(entry.getKey()), basePackage,
						entry.getValue(), autoGeneRatedFilePath, specification);
			}
			if (entry.getValue().isArray()) {
				generateNestedCollectionClass(codeModel, Utility.constructCamelCase(entry.getKey()), basePackage,
						entry.getValue(), autoGeneRatedFilePath, specification);
			}
			JFieldVar feild = null;
			try {
				if (JavaType.getJavaType().containsKey(entry.getValue().textValue())) {
					if (entry.getValue().textValue().equalsIgnoreCase("map")
							|| entry.getValue().textValue().equalsIgnoreCase("hashMap")) {
						JClass keyType = codeModel.ref(Object.class);
						JClass valueType = codeModel.ref(Object.class);
						JClass mapClass = codeModel.ref(HashMap.class).narrow(keyType, valueType);
						feild = jc.field(JMod.PRIVATE, mapClass, entry.getKey());
					} else {
						feild = jc.field(JMod.PRIVATE,
								Class.forName(JavaType.getJavaType().get(entry.getValue().textValue())),
								entry.getKey());
					}
				} else if (entry.getValue().isArray()) {
					Class genericType = Utility.getAppClasses(specification,
							basePackage + Constant.DOMAIN_PACKAGE_NAME + Utility.constructCamelCase(entry.getKey()),
							autoGeneRatedFilePath);
					JClass detailClass = codeModel.ref(genericType);
					JClass rawLLclazz = codeModel.ref(List.class);
					JClass fieldClazz = rawLLclazz.narrow(detailClass);
					feild = jc.field(JMod.PRIVATE, fieldClazz, entry.getKey());
				} else if (entry.getValue().isObject()) {
					Class customeType = Utility.getAppClasses(specification,
							basePackage + Constant.DOMAIN_PACKAGE_NAME + Utility.constructCamelCase(entry.getKey()),
							autoGeneRatedFilePath);
					feild = jc.field(JMod.PRIVATE, customeType, entry.getKey());
				}

				else {
					throw new Exception("Field type not found");
				}
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
			// Add get method
			JMethod getter = jc.method(JMod.PUBLIC, feild.type(), "get" + Utility.constructCamelCase(entry.getKey()));
			getter.body()._return(feild);
			getter.javadoc().add("Returns the " + feild.type().fullName() + Constant.CURRENT_DIR);
			getter.javadoc().addReturn().add(feild.name());

			// Add set method
			JMethod setter = jc.method(JMod.PUBLIC, codeModel.VOID, "set" + Utility.constructCamelCase(entry.getKey()));
			setter.param(feild.type(), feild.name());
			setter.body().assign(JExpr._this().ref(feild.name()), JExpr.ref(feild.name()));
			setter.javadoc().add("Set the " + feild.type().fullName() + Constant.CURRENT_DIR);
			setter.javadoc().addParam(feild.name()).add("the new " + feild.type().fullName());

		}

		codeModel.build(new File(autoGeneRatedFilePath));
		Utility.compileClasses(specification, jp.getPackage().name(), jc.name(), autoGeneRatedFilePath);
	}

	private static void generateNestedCollectionClass(JCodeModel codeModel, String className, String basePackage,
			JsonNode node, String autoGeneRatedFilePath, ApiSpecification specification)
			throws Exception, IOException, JClassAlreadyExistsException {
		JPackage jp = codeModel._package(basePackage + PACKAGE_NAME);
		JDefinedClass jc = null;
		if (jp._getClass(className) != null) {
			jc = jp._getClass(className);
		} else {
			jc = jp._class(className);
			jc._implements(Serializable.class);
			jc.javadoc().add("Auto generated " + jc.name() + " class");
			jc.constructor(JMod.PUBLIC).javadoc().add("Creates a new " + jc.name() + Constant.CURRENT_DIR);
			jc.field(JMod.STATIC | JMod.FINAL, Long.class, "serialVersionUID", JExpr.lit(1L));
		}

		if (node.elements().hasNext()) {
			JsonNode nestedNode = node.elements().next();
			Iterator<Map.Entry<String, JsonNode>> itr = nestedNode.fields();
			while (itr.hasNext()) {
				Map.Entry<String, JsonNode> entry = itr.next();
				if (entry.getValue().isObject()
						&& entry.getValue().asToken().START_OBJECT.name().equals("START_OBJECT")) {
					generateObjectClass(codeModel, Utility.constructCamelCase(entry.getKey()), basePackage,
							entry.getValue(), autoGeneRatedFilePath, specification);
				}
				if (entry.getValue().isArray()) {
					generateNestedCollectionClass(codeModel, Utility.constructCamelCase(entry.getKey()), basePackage,
							entry.getValue(), autoGeneRatedFilePath, specification);
				}
				JFieldVar feild = null;
				try {
					if (JavaType.getJavaType().containsKey(entry.getValue().textValue())) {
						if (entry.getValue().textValue().equalsIgnoreCase("map")
								|| entry.getValue().textValue().equalsIgnoreCase("hashMap")) {
							JClass keyType = codeModel.ref(Object.class);
							JClass valueType = codeModel.ref(Object.class);
							JClass mapClass = codeModel.ref(HashMap.class).narrow(keyType, valueType);
							feild = jc.field(JMod.PRIVATE, mapClass, entry.getKey());
						} else {
							feild = jc.field(JMod.PRIVATE,
									Class.forName(JavaType.getJavaType().get(entry.getValue().textValue())),
									entry.getKey());
						}
					} else if (entry.getValue().isArray()) {
						Class genericType = Utility.getAppClasses(specification,
								basePackage + Constant.DOMAIN_PACKAGE_NAME + Utility.constructCamelCase(entry.getKey()),
								autoGeneRatedFilePath);
						JClass detailClass = codeModel.ref(genericType);
						JClass rawClazz = codeModel.ref(List.class);
						JClass fieldClazz = rawClazz.narrow(detailClass);
						feild = jc.field(JMod.PRIVATE, fieldClazz, entry.getKey());
					} else if (entry.getValue().isObject()) {
						Class customType = Utility.getAppClasses(specification,
								basePackage + Constant.DOMAIN_PACKAGE_NAME + Utility.constructCamelCase(entry.getKey()),
								autoGeneRatedFilePath);
						feild = jc.field(JMod.PRIVATE, customType, entry.getKey());
					} else {
						// throw new Exception("Field type not found");
					}
				} catch (ClassNotFoundException e) {
					e.printStackTrace();
				}
				// Add get method
				JMethod getter = jc.method(JMod.PUBLIC, feild.type(),
						"get" + Utility.constructCamelCase(entry.getKey()));
				getter.body()._return(feild);
				getter.javadoc().add("Returns the " + feild.type().fullName() + Constant.CURRENT_DIR);
				getter.javadoc().addReturn().add(feild.name());

				// Add set method
				JMethod setter = jc.method(JMod.PUBLIC, codeModel.VOID,
						"set" + Utility.constructCamelCase(entry.getKey()));
				setter.param(feild.type(), feild.name());
				setter.body().assign(JExpr._this().ref(feild.name()), JExpr.ref(feild.name()));
				setter.javadoc().add("Set the " + feild.type().fullName() + Constant.CURRENT_DIR);
				setter.javadoc().addParam(feild.name()).add("the new " + feild.type().fullName());
			}
		}
		codeModel.build(new File(autoGeneRatedFilePath));
		Utility.compileClasses(specification, jp.getPackage().name(), jc.name(), autoGeneRatedFilePath);
	}

	private static void generateObjectClass(JCodeModel codeModel, String className, String basePackage, JsonNode node,
			String autoGeneRatedFilePath, ApiSpecification specification)
			throws Exception, IOException, JClassAlreadyExistsException {
		JPackage jp = codeModel._package(basePackage + PACKAGE_NAME);
		JDefinedClass jc = null;
		if (jp._getClass(className) != null) {
			jc = jp._getClass(className);
		} else {
			jc = jp._class(className);
			jc._implements(Serializable.class);
			jc.javadoc().add("Auto generated " + jc.name() + " class");
			jc.constructor(JMod.PUBLIC).javadoc().add("Creates a new " + jc.name() + Constant.CURRENT_DIR);
			jc.field(JMod.STATIC | JMod.FINAL, Long.class, "serialVersionUID", JExpr.lit(1L));
		}
		Iterator<Map.Entry<String, JsonNode>> itr = node.fields();
		while (itr.hasNext()) {
			Map.Entry<String, JsonNode> entry = itr.next();
			if (entry.getValue().isArray()) {
				generateNestedCollectionClass(codeModel, Utility.constructCamelCase(entry.getKey()), basePackage,
						entry.getValue(), autoGeneRatedFilePath, specification);
			}
			if (entry.getValue().isObject() && entry.getValue().asToken().START_OBJECT.name().equals("START_OBJECT")) {
				generateObjectClass(codeModel, Utility.constructCamelCase(entry.getKey()), basePackage,
						entry.getValue(), autoGeneRatedFilePath, specification);
			}
			JFieldVar feild = null;
			try {
				if (JavaType.getJavaType().containsKey(entry.getValue().textValue())) {
					if (entry.getValue().textValue().equalsIgnoreCase("map")
							|| entry.getValue().textValue().equalsIgnoreCase("hashMap")) {
						JClass keyType = codeModel.ref(Object.class);
						JClass valueType = codeModel.ref(Object.class);
						JClass mapClass = codeModel.ref(HashMap.class).narrow(keyType, valueType);
						feild = jc.field(JMod.PRIVATE, mapClass, entry.getKey());
					} else {
						feild = jc.field(JMod.PRIVATE,
								Class.forName(JavaType.getJavaType().get(entry.getValue().textValue())),
								entry.getKey());
					}
				} else if (entry.getValue().isArray()) {
					Class genericType = Utility.getAppClasses(specification,
							basePackage + Constant.DOMAIN_PACKAGE_NAME + Utility.constructCamelCase(entry.getKey()),
							autoGeneRatedFilePath);
					JClass detailClass = codeModel.ref(genericType);
					JClass rawClazz = codeModel.ref(List.class);
					JClass fieldClazz = rawClazz.narrow(detailClass);
					feild = jc.field(JMod.PRIVATE, fieldClazz, entry.getKey());
				} else if (entry.getValue().isObject()) {
					Class customType = Utility.getAppClasses(specification,
							basePackage + Constant.DOMAIN_PACKAGE_NAME + Utility.constructCamelCase(entry.getKey()),
							autoGeneRatedFilePath);
					feild = jc.field(JMod.PRIVATE, customType, entry.getKey());
				} else {
					throw new Exception("Field type not found");
				}
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
			// Add get method

			JMethod getter = jc.method(JMod.PUBLIC, feild.type(), "get" + Utility.constructCamelCase(entry.getKey()));
			getter.body()._return(feild);
			getter.javadoc().add("Returns the " + feild.type().fullName() + Constant.CURRENT_DIR);
			getter.javadoc().addReturn().add(feild.name());

			// Add set method
			JMethod setter = jc.method(JMod.PUBLIC, codeModel.VOID, "set" + Utility.constructCamelCase(entry.getKey()));
			setter.param(feild.type(), feild.name());
			setter.body().assign(JExpr._this().ref(feild.name()), JExpr.ref(feild.name()));
			setter.javadoc().add("Set the " + feild.type().fullName() + Constant.CURRENT_DIR);
			setter.javadoc().addParam(feild.name()).add("the new " + feild.type().fullName());
		}

		codeModel.build(new File(autoGeneRatedFilePath));
		Utility.compileClasses(specification, jp.getPackage().name(), jc.name(), autoGeneRatedFilePath);
	}

}
